<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Algorithm Benchmarks</title>
    <script
      src="https://cdn.jsdelivr.net/npm/plotly.js@3.1.0/dist/plotly.min.js"
      integrity="sha256-Ei4740bWZhaUTQuD6q9yQlgVCMPBz6CZWhevDYPv93A="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"
      integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/semantic-ui@2.5.0/dist/semantic.min.js"
      integrity="sha256-fN8vcX2ULyTDspVTHEteK8hd3rQAb5thNiwakjAW75Q="
      crossorigin="anonymous"
    ></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/semantic-ui@2.5.0/dist/semantic.min.css"
      integrity="sha256-cDGQ39yChhpN5vzgHbjIdGEtQ5kXE9tttCsI7VR9TuY="
      crossorigin="anonymous"
    />
    <style>
      .ui.container {
        padding: 2em;
        padding-top: 4em;
      }
      #tree {
        max-width: 400px;
        border: 1px solid #ccc;
        border-radius: 8px;
        background: #fafafa;
        padding: 1em;
      }
      #tree .ui.accordion {
        margin: 0;
      }
      #tree .ui.accordion > .content {
        padding: 0 1.5em;
      }
      #tree .scenario-checkbox {
        display: block !important;
        margin: 0.5em;
      }
      #plot {
        width: 100%;
        min-height: 400px;
      }
      @media (max-width: 600px) {
        #tree {
          max-width: 100%;
        }
        #plot {
          min-height: 300px;
        }
      }
      @media (prefers-color-scheme: dark) {
        body {
          background: #111;
          color: #eee;
        }
        #tree {
          background: #111;
          border-color: #444;
          color: #eee;
        }
        .ui.container,
        .ui.segment {
          background: #111 !important;
          color: #eee !important;
        }
        .ui.toggle.checkbox label,
        .ui.checkbox label {
          color: #eee !important;
        }
        .ui.accordion .title {
          color: #eee !important;
        }
        .ui.accordion .content {
          color: #eee !important;
        }
        .ui.toggle.checkbox .box:before,
        .ui.toggle.checkbox label:before {
          background: rgba(255, 255, 255, 0.1) !important;
        }
      }

      body .ui.segment,
      body .ui.dropdown,
      body .header,
      body .content,
      body .ui.icon:not(.button):not(.item):not(.message),
      body .ui.breadcrumb .icon.divider,
      body .ui.input,
      body input,
      body .ui.form .inline.fields > label,
      body .ui.input textarea,
      body .ui.form textarea,
      body .ui.radio.checkbox input ~ label,
      body .ui.toggle.checkbox input ~ label,
      body .ui.toggle.checkbox input:checked ~ label,
      body .ui.toggle.checkbox input:focus:checked ~ label,
      body .ui.checkbox label:hover,
      body .ui.checkbox + label:hover,
      body .ui.checkbox label,
      body .ui.checkbox + label,
      body .ui.form .field > label,
      body .ui.selection.visible.dropdown > .text:not(.default),
      body .ui.menu .ui.dropdown .menu > .active.item,
      body .ui.menu .ui.dropdown .menu > .item:hover,
      body .ui.accordion,
      body .ui.accordion > .title,
      body .ui.accordion > .content,
      body table,
      body tr,
      body td,
      body th {
        background: inherit !important;
        color: inherit !important;
      }
    </style>
  </head>
  <body>
    <div class="ui container">
      <h2 class="ui header">Algorithm Benchmarks</h2>
      <div class="ui grid stackable">
        <div class="four wide column">
          <div class="ui toggle checkbox" style="margin-bottom: 1em">
            <input type="checkbox" id="constantToggle" checked />
            <label for="constantToggle">Show constant</label>
          </div>
          <div id="tree" class="ui fluid"></div>
        </div>
        <div class="twelve wide column">
          <div id="plot"></div>
          <div id="details" class="ui segment" style="display: none"></div>
        </div>
      </div>
    </div>
    <script>
      // Load results.json
      fetch("results.json")
        .then((r) => r.json())
        .then((data) => {
          window._resultsData = data;
          buildTree(data);
        });

      function buildTree(results) {
        // Build a nested Map tree from keys
        function buildNestedTree(keys) {
          const root = new Map();
          for (const key of keys) {
            const parts = key.split(".");
            let node = root;
            for (let i = 0; i < parts.length - 1; ++i) {
              if (!node.has(parts[i])) node.set(parts[i], new Map());
              node = node.get(parts[i]);
            }
            node.set(parts[parts.length - 1], key);
          }
          return root;
        }

        // Recursively render the tree as Semantic UI accordions
        function renderTree(node) {
          let html = "";
          for (const [k, v] of node.entries()) {
            if (typeof v === "string") {
              // Leaf node as checkbox, with line break
              html += `<div class="ui checkbox scenario-checkbox"><input type="checkbox" data-key="${v}"><label>${k}</label></div>`;
            } else {
              html += `<div class="ui accordion"><div class="title"><i class="dropdown icon"></i>${k}</div>`;
              html += '<div class="content">' + renderTree(v) + "</div></div>";
            }
          }
          return html;
        }

        const tree = document.getElementById("tree");
        tree.innerHTML = renderTree(buildNestedTree(Object.keys(results)));

        $("#tree>.accordion").accordion({ exclusive: false, duration: 100 });

        // Checkbox handler for overlaying scenarios
        const checkboxes = tree.querySelectorAll("input[type=checkbox][data-key]");
        checkboxes.forEach((cb) => {
          cb.onchange = () => {
            // Get all checked scenarios
            const checked = Array.from(tree.querySelectorAll("input[type=checkbox][data-key]:checked"));
            const selectedKeys = checked.map((c) => c.dataset.key);
            showOverlayPlot(
              selectedKeys.map((k) => results[k]),
              selectedKeys
            );
          };
        });
      }

      function showOverlayPlot(resultsArr, keysArr) {
        const plotDiv = document.getElementById("plot");
        const detailsDiv = document.getElementById("details");
        const use_c = document.getElementById("constantToggle")?.checked;
        if (!resultsArr.length) {
          plotDiv.innerHTML = "";
          detailsDiv.style.display = "none";
          return;
        }
        // Determine axis scale: log-linear if all are log-linear, else log-log
        let xType = "log",
          yType = "log";

        const logRegex = /O\((log n|logn)\)/i;
        if (use_c) {
          yType = "linear";
        } else if (resultsArr.length > 0) {
          const allLogLinear = resultsArr.every((r) => logRegex.test(r.complexity));
          if (allLogLinear) {
            yType = "linear";
          }
        }
        // Build traces for each scenario
        const traces = [];
        const colorScheme = [
          "#1f77b4",
          "#ff7f0e",
          "#2ca02c",
          "#d62728",
          "#9467bd",
          "#8c564b",
          "#e377c2",
          "#7f7f7f",
          "#bcbd22",
          "#17becf",
        ];
        resultsArr.forEach((result, idx) => {
          const xs = [],
            ys = [],
            errors = [];
          result.stats.forEach((d) => {
            const n = Number(d.n);
            if (use_c) {
              ys.push(d.mean_c);
              errors.push(d.stddev_c);
            } else {
              ys.push(d.mean);
              errors.push(d.stddev);
            }
            xs.push(n);
          });

          traces.push({
            x: xs,
            y: ys,
            error_y: { type: "data", array: errors, visible: true },
            mode: "markers",
            type: "scatter",
            name: keysArr[idx],
            marker: { color: colorScheme[idx % colorScheme.length] },
          });
        });
        // Plotly layout dark mode detection
        const isDark = window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
        const plotLayout = {
          title: keysArr.join(" + "),
          xaxis: { title: "Input size (n)", type: xType, color: isDark ? "#eee" : undefined },
          yaxis: {
            title: use_c ? "Time / Complexity" : "Time per repeat (ns)",
            type: yType,
            color: isDark ? "#eee" : undefined,
          },
          legend: { orientation: "h", font: { color: isDark ? "#eee" : undefined } },
          margin: { t: 40 },
          paper_bgcolor: isDark ? "#181818" : undefined,
          plot_bgcolor: isDark ? "#111" : undefined,
          font: { color: isDark ? "#eee" : undefined },
        };
        Plotly.newPlot(plotDiv, traces, plotLayout, { responsive: true });
        // Details
        detailsDiv.style.display = "";
        detailsDiv.innerHTML = resultsArr
          .map((result, idx) => {
            return [
              `<b>Algorithm:</b> ${keysArr[idx]}`,
              `<b>Type:</b> ${result.type}`,
              `<b>Complexity:</b> ${result.complexity}`,
              `<b>Max Constant:</b> ${typeof result.max_c === "number" ? result.max_c.toFixed(3) : result.max_c}`,
            ].join("<br>");
          })
          .join("<hr>");
      }

      // Replot on toggle change
      document.addEventListener("DOMContentLoaded", function () {
        const toggle = document.getElementById("constantToggle");
        if (toggle) {
          toggle.addEventListener("change", function () {
            // Find checked scenarios and replot
            const tree = document.getElementById("tree");
            const checked = Array.from(tree.querySelectorAll("input[type=checkbox][data-key]:checked"));
            const selectedKeys = checked.map((c) => c.dataset.key);
            if (window._resultsData) {
              showOverlayPlot(
                selectedKeys.map((k) => window._resultsData[k]),
                selectedKeys
              );
            }
          });
        }
      });
    </script>
  </body>
</html>
